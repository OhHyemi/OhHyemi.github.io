<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>너비우선탐색 on Hyemi&#39;s Blog</title>
    <link>https://ohhyemi.github.io/tags/%EB%84%88%EB%B9%84%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89/</link>
    <description>Recent content in 너비우선탐색 on Hyemi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 01 Dec 2021 20:08:00 +0900</lastBuildDate><atom:link href="https://ohhyemi.github.io/tags/%EB%84%88%EB%B9%84%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BFS: 너비우선탐색, DFS: 깊이우선탐색(2)</title>
      <link>https://ohhyemi.github.io/posts/studying8_bfs_dfs2/</link>
      <pubDate>Wed, 01 Dec 2021 20:08:00 +0900</pubDate>
      
      <guid>https://ohhyemi.github.io/posts/studying8_bfs_dfs2/</guid>
      <description>음&amp;hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다. 나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실&amp;hellip;!😱 그래서 오늘 공부해보려고 한다.
BFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.</description>
    </item>
    
    <item>
      <title>BFS: 너비우선탐색, DFS: 깊이우선탐색(1)</title>
      <link>https://ohhyemi.github.io/posts/studying7_bfs_dfs/</link>
      <pubDate>Mon, 29 Nov 2021 21:40:04 +0900</pubDate>
      
      <guid>https://ohhyemi.github.io/posts/studying7_bfs_dfs/</guid>
      <description>음&amp;hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다&amp;hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서.. 원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋
Graph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.
 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법
 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i &amp;lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List&amp;lt;int&amp;gt;[] Graph = new List&amp;lt;int&amp;gt;[V + 1]; for (int i = 1; i &amp;lt; N + 1; i++) { Graph[i] = new List&amp;lt;int&amp;gt;(); foreach(v in AdjacencyVertices) { Graph[i].</description>
    </item>
    
  </channel>
</rss>
