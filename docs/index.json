[{"content":"git을 이용을 하는데\u0026hellip; 내가 아는 것이라고는 오로지 add-\u0026gt;commit-\u0026gt;push밖에 없어서 좀 더 알아보고자 포스팅을 하기로 했다.\ngit이 뭐야? 🧐  버전 관리 시스템(VCS) 백업   원격 저장소에 저장해서 어디에서든지 내려받아 작업을 수행할 수 있다. 이전 버전으로 돌아갈 수 있다.   협업   다른 사람이 수정한 내역도 원격 서버에 올라가 있다면 자신의 저장소에도 적용이 가능 commit내역을 통해 누가 무엇을 수정했는지 알 수 있음. branch를 통해 각자 기능을 만들고 이것들을 병합하여 하나의 branch로 만들 수 있음.(충돌에 유의해야함)  💛워킹 디렉터리  사용자가 실제로 작업하는 작업공간.  💛스테이지 영역  임시영역 워킹 디렉터리에서 생성하거나 수정한 파일을 git add 명령어를 사용할 시 이곳으로 저장됨. 이 영역의 파일들은 모두 tracked 상태.  💚tracked 상태  git이 파일을 추적할 수 있는 상태. 생성 후 git add 명령어를 수행한 상태. 파일 수정이 이루어졌는지 확인이 가능한 상태.  💚untracked 상태  git이 파일을 추적할 수 없는 상태. 생성 후 git add 명령어를 수행하지 않은 상태. 파일을 수정해도 git이 알 수 없는 상태.  💚staged 상태  워킹 디렉터리에서 수행한 작업들(생성,수정 모두)이 git add 명령어를 통해 스테이지 영역에 올라온 상태.  💚unstaged 상태  워킹 디렉터리에서 새로 생성한 파일을 아직 git add 명령어를 수행하지 않은 상태.(+ untracked 상태) 기존 staged 상태의 파일을 수정하고 git add 명령어를 수행하지 않은 상태.(+ modified 상태 + tracked 상태)  💚modified 상태  tracked 상태의 파일을 수정후 git add 명령어를 수행하지 않은 상태. git add 명령어를 수행해줘야 하는 상태.  💚unmodified 상태  스테이지로 파일을 올린 후 어떠한 수정도 없는 상태.  기본 명령어를 알아보자 🧐 0. clone  원격 저장소를 로컬 저장소에 저장하는 명령어. 기존에 저장소가 미리 만들어져 있어야함. clone 명령어 수행.  이후 생성된 파일.   1. add  워킹 디렉터리 -\u0026gt; 스테이지 영역. untracked -\u0026gt; tracked 상태 변경. git이 파일을 추적할 수 있도록 해주는 명령어. 파일 생성 또는 수정을 했을 경우(원격 저장소에 파일을 저장하고 싶다면) 반드시 해주어야 한다.  2. status  git의 현재 상태를 보여줌. test예시: test를 생성 직후에는 commit해야한다고 알려줌. 해당 파일 수정후 modified되었다고 알려줌.   3. commit  변화된 내옹을 저장소에 기록. 반드시 tracked 상태여야 함. 스테이지 영역에 새로운 변경 내용이 있어야 함. add 되어 있던 파일들을 기록. -m를 통해 짧은 메세지를 추가 할 수 있다. test예시: 수정된 Test.txt를 커밋해보았다.   4. rm --cached  파일을 잘못 올렸을 경우 사용. staged -\u0026gt; untracked 상태 변경. commit에 반영하고 싶지않을 경우에 사용. test 예시   5. reset HEAD  commit을 한 파일을 rm 을 통해 untracked상태로 변경하였다면 이 명령어를 사용하여 파일을 정리해주어야함. \u0026lt;- 사실 이해가 잘 가지않음\u0026hellip;  6. checkout 파일이름  해당 파일을 이전 commit 내용으로 되돌림. test예시: 변경을 commit = 기존 change만 있던 내용에 miss 단어 추가.  test예시: checkout 후 결과 = 다시 이전의 chnage만 있던 상태로 돌아감.  7. log  commit 내역 조회.   참고 \u0026ldquo;Git 교과서\u0026rdquo;\n","permalink":"https://ohhyemi.github.io/posts/studying17_git1/","summary":"git을 이용을 하는데\u0026hellip; 내가 아는 것이라고는 오로지 add-\u0026gt;commit-\u0026gt;push밖에 없어서 좀 더 알아보고자 포스팅을 하기로 했다.\ngit이 뭐야? 🧐  버전 관리 시스템(VCS) 백업   원격 저장소에 저장해서 어디에서든지 내려받아 작업을 수행할 수 있다. 이전 버전으로 돌아갈 수 있다.   협업   다른 사람이 수정한 내역도 원격 서버에 올라가 있다면 자신의 저장소에도 적용이 가능 commit내역을 통해 누가 무엇을 수정했는지 알 수 있음. branch를 통해 각자 기능을 만들고 이것들을 병합하여 하나의 branch로 만들 수 있음.","title":"Git(1)"},{"content":"dp문제에 너무 약한 나\u0026hellip; 문제를 작게 쪼개서 푸는 방법을 잘 생각해봐야겠다..\n알고리즘 공부 백준 11727 🧐 제로 👉문제 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.\n아래 그림은 2×17 직사각형을 채운 한가지 예이다.\n👉입력 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)\n👉출력 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  using System; namespace Algorithm21 { class Beakjoon11727 { private static long mod = 10007; static void Main(string[] args) { var n = int.Parse(Console.ReadLine()!); long[] arr = new long[n + 1]; arr[1] = 1; //1*2 블록 하나  if (n \u0026gt; 1) { arr[2] = 3; //2*2 블록 하나 or 2*1블록 둘 or 1*2블록 둘  } //방법1  // 한 칸이 비워져 있다고 했을 때 그 한 칸을 채우는 방법은 하나이다.  // 두 칸이 비워져 있다고 했을 때 그 두 칸을 채우는 방법은 세가지 이지만,  // 1*2블록 둘의 경우는 한 칸이 비워져 있을 경우랑 같은 경우로 생각할 수 있다.  // 따라서, 2*2 블록 하나 or 2*1블록 둘 -\u0026gt; 두가지의 방법이 있다.  // 3부터 arr[n] = arr[n - 1] + 2 * arr[n - 2]  for (int i = 3; i \u0026lt;= n; i++) { arr[i] = (arr[i - 1] + 2 * arr[i - 2]) % mod; } Console.WriteLine(arr[n]); //방법2  //공식 도출: [n번째의 값] = 2^(n-1) + [n-2번째의 값]  long GetAn(int index) { if (arr[index] != 0) { return arr[index]; } arr[index] = (MyPownMod(2, index - 1) + GetAn(index - 2)) % mod; return arr[index]; } Console.WriteLine(GetAn(n)); } //빠른 거듭제곱 알고리즘.. + MOD  static long MyPownMod(long _base, long _exp) { long let = 1; while (_exp \u0026gt; 1) { var temp = _exp \u0026amp; 1; //홀수냐 짝수냐  if (temp == 1) //홀수  { let = (_base * let) % mod; //mod를 계속 해주는 이유  //값이 넘어가 overflow가 될 수 있기 때문...  } _base = _base * _base % mod; _exp \u0026gt;\u0026gt;= 1; } return (_base * let) % mod; } } }   🍏공식도출 방법을 사용했을 때 겪었던 문제점  n의 범위가 1~1000까지 였기 때문에 거듭제곱을 사용할 때 오버플로우가 일어났다. 그 결과 이상한 값이 나왔다. 빠른거듭제곱 알고리즘을 사용한 이유: 거듭제곱을 할 때마다 오버플로우가 되지않게 mod처리!  문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm21_11727/","summary":"dp문제에 너무 약한 나\u0026hellip; 문제를 작게 쪼개서 푸는 방법을 잘 생각해봐야겠다..\n알고리즘 공부 백준 11727 🧐 제로 👉문제 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.\n아래 그림은 2×17 직사각형을 채운 한가지 예이다.\n👉입력 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)\n👉출력 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  using System; namespace Algorithm21 { class Beakjoon11727 { private static long mod = 10007; static void Main(string[] args) { var n = int.","title":"AlgorithmStudy_백준 11727"},{"content":"해시가 뭐야? 🧐  해시(Hash)는 키 값을 해시 함수(Hash function)으로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식이다.\n 해시테이블이 뭐야? 🧐  해시 테이블은 연관배열 구조를 이용하여 키(key)에 결과 값(value)을 저장하는 자료구조이다.\n 연관배열 구조(associative array)란, 키(key) 1개와 값(value) 1개가 1:1로 연관되어 있는 자료구조이다. 따라서 키(key)를 이용하여 값(value)을 도출할 수 있다.\n  key 와 value는 일대일 매핑으로 같은 value값을 가질 순 있어도, 같은 key값은 가지지 못한다.\n1. 해시테이블(HashTable) 클래스  Non-generic 클래스. key와 value를 가지고 있음 -\u0026gt; 둘다 object 타입으로 받음 -\u0026gt; boxing/unboxing이 일어난다. Double Hashing 방식을 사용  💚 Double Hashing 이란? 해시충돌이 일어날 경우 한 번 더 다른 해시함수를 거쳐 새로운 해시코드를 생성하여 해시충돌을 막는 방법.\n💚 해시충돌 이란? 서로 다른 키값을 가졌지만 해싱 후 가진 해시코드가 같은 경우.\nex) 만약 해시함수의 알고리즘이 문자열의 길이를 반환한다고 가정하였을 경우, cake와 taco는 4라는 해시코드를 가지게 된다. key는 서로 다르지만 해시코드가 이처럼 같은 경우를 해시충돌이라고 한다.\n2. 딕셔너리(Dictionary) 클래스  Generic 클래스. key와 value를 가지고 있음 -\u0026gt; Generic으로 타입을 지정 -\u0026gt; boxing/unboxing 일어나지 않음! Chaining 방식을 사용  💚 Chaining 이란? linked list로 해당값을 기존값에 연결시키는 방법이다.\n","permalink":"https://ohhyemi.github.io/posts/studying16_hash/","summary":"해시가 뭐야? 🧐  해시(Hash)는 키 값을 해시 함수(Hash function)으로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식이다.\n 해시테이블이 뭐야? 🧐  해시 테이블은 연관배열 구조를 이용하여 키(key)에 결과 값(value)을 저장하는 자료구조이다.\n 연관배열 구조(associative array)란, 키(key) 1개와 값(value) 1개가 1:1로 연관되어 있는 자료구조이다. 따라서 키(key)를 이용하여 값(value)을 도출할 수 있다.\n  key 와 value는 일대일 매핑으로 같은 value값을 가질 순 있어도, 같은 key값은 가지지 못한다.\n1. 해시테이블(HashTable) 클래스  Non-generic 클래스.","title":"HashTable: 해시테이블"},{"content":"아래 이미지는 만든 배너의 모습이다. UI리소스는 친구가 만들어줬다..ㅎㅎ\n💚 만들면서 고민한 것들.\n 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!\n 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.\n Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!\n 버튼 추가  각 banner로 바로 이동할 수 있는 버튼을 추가! 해당 banner로 이동할 때 바로 보여주는 것이 아닌, 이동 연출을 보여주었다.\n🍑 snap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void ScrollSnap(Vector2 value) //ScrollRect.onValueChanged.AddListener(ScrollSnap)에 추가해줌. { //유저가 스크롤을 조작하고 있는 경우 or 오토무브가 가능한 경우 or 배너가 움직이는 중일 경우(버튼 조작으로)  if (BannerScrollRect.isOnDown || isAbleAutoMove || isBannerMoving) { return; } if (value.x \u0026gt; points[curBannerIndex]) //오른쪽 snap  { if (value.x \u0026gt;= points[curBannerIndex] + snapRange) { var nextIndex = curBannerIndex + 1 \u0026gt;= datas.Length ? 0 : curBannerIndex + 1; MoveBannerByIndex(nextIndex);//해당인덱스로 이동  } else { MoveBannerByIndex(curBannerIndex); } } else //왼쪽 snap  { if (value.x \u0026lt;= points[curBannerIndex] - snapRange) { var prevIndex = curBannerIndex - 1 \u0026lt; 0 ? 0 : curBannerIndex - 1; MoveBannerByIndex(prevIndex); } else { MoveBannerByIndex(curBannerIndex); } } }   🍑 배너 이동 코루틴\n이전에 포스팅했던 타이머를 활용해보자!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  IEnumerator CoMoveBanner(int index) { curBannerIndex = index; indexButtons[curBannerIndex].SelectWithoutNotify(true); var timer = 0f; var startPoint = BannerScrollRect.ScrollRect.horizontalNormalizedPosition; while (timer \u0026lt; duration) //duration 동안 이동  { timer += Time.deltaTime; //스크롤 포인트 조절! lerp를 사용하여 부드럽게 이동시키자!  BannerScrollRect.ScrollRect.horizontalNormalizedPosition = Mathf.Lerp(startPoint, points[index], ease.Evaluate(timer / duration)); yield return null; } isAbleAutoMove = true;//오토무브 가능으로 변경  isBannerMoving = false;//배너 움직임이 끝났음을 알림  autoTimer = 0; //무브를 조작했다면 오토무브 타이머를 초기화 }   ","permalink":"https://ohhyemi.github.io/posts/studying15_snap/","summary":"아래 이미지는 만든 배너의 모습이다. UI리소스는 친구가 만들어줬다..ㅎㅎ\n💚 만들면서 고민한 것들.\n 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!\n 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.\n Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!","title":"배너를 만들어보자!"},{"content":"알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에\u0026hellip;ㅎㅎ\n알고리즘 공부 백준 2667 🧐 제로 👉문제 \u0026lt;그림 1\u0026gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. \u0026lt;그림 2\u0026gt;는 \u0026lt;그림 1\u0026gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.\n👉입력 첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.\n👉출력 첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  namespace Algorithm19 { class Baekjoon2667 { static void Main(string[] args) { char house = \u0026#39;1\u0026#39;; char visitedHouse = \u0026#39;2\u0026#39;; int N = int.Parse(Console.ReadLine()!); var arr = new char[N,N]; var list = new char[N]; for (int i = 0; i \u0026lt; N; i++) { list = Console.ReadLine()!.ToCharArray(); for (int j = 0; j \u0026lt; N; j++) { arr[i,j] = list[j]; } } List\u0026lt;int\u0026gt; countList = new List\u0026lt;int\u0026gt;(); int c = 0; for (int r= 0; r \u0026lt; N; r++) { for (; c \u0026lt; N; c++) { if (arr[r, c] != house) { continue; } countList.Add(DFS(r, c)); } c = 0; } Console.WriteLine(countList.Count); countList.Sort(); for (int i = 0; i \u0026lt; countList.Count; i++) { Console.WriteLine(countList[i]); } int DFS(int r, int c) { int cnt = 0; if (arr[r, c] == house) { arr[r, c] = visitedHouse; cnt++; } //방법1  if (r + 1 \u0026lt; N \u0026amp;\u0026amp; arr[r + 1, c] == house) //오른쪽  { cnt += DFS(r + 1, c); } if (r - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[r - 1, c] == house) //왼쪽  { cnt += DFS(r - 1, c); } if (c - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[r, c - 1] == house) //아래쪽  { cnt += DFS(r, c - 1); } if (c + 1 \u0026lt; N \u0026amp;\u0026amp; arr[r, c + 1] == house) //위쪽  { cnt += DFS(r, c + 1); } //방법2  //상하좌우(4 Way) 움직임..  int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; for(int d = 0; d \u0026lt; 4; d++) // 상하좌우 탐색  { int nX = x + dx[d]; // 새로운 x좌표  int nY = y + dy[d]; // 새로운 y좌표  if(nX \u0026lt; 0 || nX \u0026gt;= N || nY \u0026lt; 0 || nY \u0026gt;= N) // Out of Bound 체크 - 맵의 경계를 넘어가나 체크하는 것이다.  { continue; } if(board[nX, nY] == house) // 새로 이동할 위치에 아파트 건물이 있고, 아직 방문하지 않은 정점이라면  { DFS(nX, nY); // 이 위치에서 DFS 호출  } } return cnt; } } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm19_2667/","summary":"알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에\u0026hellip;ㅎㅎ\n알고리즘 공부 백준 2667 🧐 제로 👉문제 \u0026lt;그림 1\u0026gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다.","title":"AlgorithmStudy_백준 2667"},{"content":"가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.\n그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.\n힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다. 만약 없다면, 유니티는 가비지 컬렉터 작동을 시켜 메모리가 생기면 변수를 할당한다. 가비지 컬렉터 실행 후에도 메모리가 없을 경우에는 힙공간을 늘린 후 변수를 할당한다.  가비지 컬렉션이 진행될 때 무슨 일이 일어날까? 🧐  힙메모리에 있는 모든 오브젝트들을 조사. 모든 오브젝트들의 레퍼런스를 조사하여 현재 힙메모리에 있는 오브젝트가 스코프에 남아있는지 확인한다. 더 이상 스코프 안에 있지 않은 오브젝트들을 마크한다. 마크된 오브젝트를 메모리해제하여 메모리를 다시 사용할 수 있는 상태로 만든다.  가비지 컬렉터가 작동해야하는 상황, 유니티가 힙공간을 늘려야하는 상황 모두 성능의 저하를 가져온다.\n가비지 컬렉션는 언제 작동할까? 🧐  힙메모리 할당을 요청 받았을 때, 할당이 불가능한 경우.(메모리 자체의 부족 또는 메모리 단편화 상태) 가비지 컬렉터는 자동적으로 작동을 한다.(플랫폼에 따라 작동 횟수는 다양함) 강제로도 작동시킬 수 있지만 권장하지 않는다.(비용이 많이 든다!)  가비지 컬렉션의 문제점은? 🧐  비용이 많이 든다.(어떤 메모리를 청소해야할지 찾는 데에 시간이 듬) 어떠한 타이밍에 실행될지 모른다.(ex. cpu가 게임에서 중요한 부분을 작업하는데 가비지 컬렉션이 일어나면 아무리 작은 추가 오버헤드일지라도 프레임 드랍을 일으킬 수 있다.) 메모리 단편화 문제!  가비지를 줄이려면? 🧐  캐싱: 반복적으로 호출하여 할당하지만 그 결과가 버려지는 오브젝트들을 캐싱해두고 다시 사용하자. 자주 사용되는 함수에서 힙 할당을 자제하자.(update 같은 함수) Collection사용시 Clear()해서 재사용하기.(캐싱해서 사용해라~ new로 새로 만들지 말고!) 런타임에 많은 오브젝트들을 생성하고 파괴하기 보다는 오브젝트 풀링 이용. string 사용에 주의하자! immutable, reference type 이기 때문에 string으로 조작할 때마다 이전 string은 가비지가 됨. Debug.Log() 는 디버깅할 상황이 끝나면 바로바로 지워주자! GameObject.name, GameObject.tag 같은 경우는 새로운 string을 만들어 return 해주기 때문에 GameObject.CompareTag()같은 함수를 대신 적극 이용하는 것이 좋다. 코루틴을 사용할때도 유의해야한다. yield return 시 new 키워드를 반복사용해야한다면 캐싱해놓고 사용하자.  이외에도 더 많은 줄일 수 있는 방법들이 있다. 참고 링크\n","permalink":"https://ohhyemi.github.io/posts/studying14_gc/","summary":"가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.\n그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.\n힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다.","title":"GarbageCollection: 가비지 컬렉션"},{"content":"🍑 타이머\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!  if (timer \u0026gt;= time) { break; } //시간을 더해주자!  timer += Time.deltaTime; yield return null; //남은 시간을 보내주기  onValueChanged(time - timer); } //타이머가 끝나면 코루틴을 null  curTimer = null; } }   💚 deltaTime 사용 이유!\n 지난 프레임이 완료되는 데 까지 걸린 시간을 나타내며, 단위는 초를 사용합니다.(읽기전용) 사용자의 프레임 률(frame rate)을 독립적으로 적용하기 위해서 사용합니다.\n 즉! 사용자의 각자 프레임률이 다르기 때문에 프레임 카운트로 타이머를 만든다면 각 사용자의 타이머는 시간이 모두 다르다. 하지만 deltaTime을 쓴다면, 같은 결과값을 얻을 수 있다!\n여기서, 매 프레임마다 실행되는 update와 달리 coroutine을 사용했는데 내용이 적용이 될까? 라는 의문이 들 수 있다. yield return null 을 사용함으로 update바로 다음에 실행이 되도록 하였다! 즉, update에서 사용하는 것과 동일하게 사용이 가능하다.\n🍑 스킬아이콘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  public class SpellIcon : MonoBehaviour { //연출에 사용할 커브! [SerializeField] private AnimationCurve ease; //스킬 아이콘 이미지  private Image img_icon; //쿨타임이 돌 때 이미지(딤드)  private Image img_cooltime; //쿨타임을 표시해 줄 텍스트  private Text txt_timer; //타이머를 가지고 있자!  private Timer timer; //임시 쿨타임 적용  private int cooltime = 5; private void Awake() { foreach (var img in GetComponentsInChildren\u0026lt;Image\u0026gt;()) { if (img.name == \u0026#34;Image_Spell\u0026#34;) { img_icon = img; } else if (img.name == \u0026#34;Image_CoolTime\u0026#34;) { img_cooltime = img; } } var btn = img_icon.gameObject.AddComponent\u0026lt;Button\u0026gt;(); btn.onClick.AddListener(OnClickSpell); timer = GetComponent\u0026lt;Timer\u0026gt;(); txt_timer = GetComponentInChildren\u0026lt;Text\u0026gt;(); } //바깥에서 불러줘야해!  //useAble : 바로 사용이 가능한지?  public void Initialize(Sprite sprite, int cooltime, bool useAble = true) { img_icon.sprite = sprite; this.cooltime = cooltime; //바로사용이 불가능하다면 쿨타임을 실행!  OnTimeChanged(useAble ? cooltime : 0); } void UseSpell() { img_cooltime.raycastTarget = true; timer.StartTimer(cooltime, OnTimeChanged); } void OnClickSpell() { //어디론가 보내서 스킬을 발동되도록 해야겠지 ?  Debug.Log(\u0026#34;아 스킬 발동ㅋ\u0026#34;); ClickAnimation();//연출!  UseSpell(); } void ClickAnimation() { //클릭시 커졌다가 다시 돌아오는 핑퐁형태의 연출을 추가!  transform.Scale(Vector3.one, Vector3.one * 1.1f, 0.1f).SetEase(ease,true).Play(); } //타임이 변경될 때 마다 업데이트를 시켜줌  void OnTimeChanged(float time) { UpdateCooltimeImage(time); UpdateTimerText(time); } void UpdateCooltimeImage(float time) { if (time \u0026lt;= 0) { //쿨타임이 끝났으니 아이콘을 누를 수 있도록 해당 이미지를 raycastTarget을 꺼줌.  img_cooltime.raycastTarget = false; } if (cooltime \u0026gt; 0) { img_cooltime.fillAmount = time / cooltime; } else { img_cooltime.fillAmount = 0; } } void UpdateTimerText(float time) { txt_timer.text = time \u0026lt;= 0 ? string.Empty : txt_timer.text = Math.Ceiling(time).ToString(); } }   스킬 아이콘을 초기화해주고 정보를 넣어주는 것은 원래 해당 클래스 바깥에서 관리를 해주어야 할 것이다. 이 스킬 아이콘들의 상태를 관리하고 이벤트들을 실제로 사용하는 곳으로 전달하는 역할의 매니저 클래스가 필요하다. 다음에 이 클래스를 관리하는 클래스도 추가해보겠다. 이 클래스는 실 데이터(스킬의 데미지, 타겟, 효과 등\u0026hellip;)를 다루거나 그 데이터를 기반으로 행위를 하는 것보다 사용자의 눈에 보여지는 부분만 처리하기 위해 존재한다.(UI적 부분만)\n","permalink":"https://ohhyemi.github.io/posts/studying13_timer/","summary":"🍑 타이머\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!","title":"타이머를 이용해 스킬아이콘을 만들어보자!"},{"content":"애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.\n🍑 핑퐁 기능 추가!!!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!  { if (pingpong)//핑퐁을 한다면  { Keyframe[] keyframes = new Keyframe[ease.length]; //애니메이션 커브의 키 프레임만큼 키프레임 배열 생성  for (int i = 0; i \u0026lt; ease.length; i++) { //일대일 매칭을 해서  keyframes[i] = ease.keys[i]; //정해진 기간내에 from으로 와야함.  //반절은 to로 반절은 from로 가야하기때문에 2로 나누어 줌!  keyframes[i].time = keyframes[i].time / 2; } //새로운 커브를 생성해 이전 ease와 교체  ease = new AnimationCurve(keyframes); //핑퐁으로 모드를 변경!  ease.postWrapMode = WrapMode.PingPong; } tween.Ease = ease; } else { Debug.Log(\u0026#34;tween is playing\u0026#34;); } return tween; }   💚 ease.Evaluate(time / duration) 를 통해서 총 애니메이션 기간에 대한 현재 애니메이션 타임의 값을 ease에서 얻을 수 있다. 이 값을 대상이 Transform(position, scale, rotate)이든지 MaskAbleGraphic(color, alpha), CanvasGroup(alpha)이든지 간에 값을 정해줄 수 있다.\n나중에 애니메이션커브만 따로 포스팅을 해보겠다!\n","permalink":"https://ohhyemi.github.io/posts/studying12_tweenmaking/","summary":"애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.\n🍑 핑퐁 기능 추가!!!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!","title":"Tween 만들기 프로젝트 근황"},{"content":"상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.\n💚 예시 오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다. 즉, 아무렂 직업이 없는 일반 오크(부모클래스)도 존재할 수 있고, 이 오크를 기반으로 다양한 직업을 가진 오크(자식클래스)도 존재할 수 있다.\n🍑 위의 내용을 바탕으로 코드를 만들어 보자! 🍑 일반클래스, 추상클래스, 인터페이스 모두 활용해보자!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  public abstract class Monster //몬스터라는 분류! { private int maxHp; private int maxMp; private int hp; private int mp; private bool isAbleSkill; public bool IsAbleSkill { get =\u0026gt; mp \u0026gt; 0; private set =\u0026gt; isAbleSkill = value; } private bool IsAlive=\u0026gt; hp \u0026gt; 0; public int Hp { get =\u0026gt; hp; set { var _hp = hp + value; if (_hp \u0026gt; maxHp) { hp = maxHp; } else if (_hp \u0026lt;= 0) { Die(); } else { hp = _hp; } } } public int Mp { get =\u0026gt; mp; set { var _mp = mp + value; if (_mp \u0026gt; maxMp) { mp = maxMp; } else if (_mp \u0026lt;= 0) { mp = 0; } else { mp = _mp; } } } protected Monster(int maxHp, int maxMp)//abstract 클래스의 생성자는 항상 protected로!  { this.maxHp = maxHp; this.maxMp = maxMp; hp = maxHp; mp = maxMp; } public abstract void UseSkill(); public abstract void Die(); public void SetEnableUseSkill(bool able) { isAbleSkill = able; } } public class Orc : Monster { public override void UseSkill() { if (IsAbleSkill) { Skill(); } } public Orc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected virtual void Skill() { Console.WriteLine(\u0026#34;일반오크 스킬 발동!\u0026#34;); } public override void Die() { Console.WriteLine(\u0026#34;오크 죽음!\u0026#34;); } } public class WizardOrc : Orc, IFly { public WizardOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() //부모의 함수를 오버라이딩 하여 자신에게 알맞은 함수를 실행함  { Console.WriteLine(\u0026#34;마법사 오크 스킬 발동!\u0026#34;); } public void Fly() { Console.WriteLine(\u0026#34;휘익~ 마법사 오크 난다!\u0026#34;); } } public class KnightOrc : Orc { public KnightOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() { Console.WriteLine(\u0026#34;전사오크 스킬 발동!\u0026#34;); } } public class ArcherOrc : Orc { public ArcherOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() { Console.WriteLine(\u0026#34;궁수오크 스킬 발동!\u0026#34;); } }   상속의 특징은? 🧐  자식클래스가 부모클래스의 필드와 메소드를 모두 가지고 있다. 부모클래스에서 private으로 선언되어있는 요소들은 자식클래스라도 접근이 불가능하다.(가지고는 있음!) 부모클래스에서 protected로 선언되어있는 요소는 자식클래스만 접근이 가능하다. 부모클래스이 메소드를 virtual/override 를 통해 자식클래스에서 재정의 할 수 있다. interface를 제외한 모든 상속은 다중상속이 불가능하다.  ","permalink":"https://ohhyemi.github.io/posts/studying11_inheritance/","summary":"상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.\n💚 예시 오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다.","title":"inheritance: 상속"},{"content":"오늘은 추상 클래스에 대해 알아보쟈!\nabstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.\n💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, \u0026ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.\u0026rdquo; 라는 계약이 생긴다. 🍑 위의 내용을 추가로 코드를 수정해보자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public abstract class Animal//동물이라는 카테고리를 표현 { private bool isAlive = true;//추상클래스는 필드를 가질 수 있다.  public abstract void Eat();//추상메소드: 자식클래스에서 모두 구현을 해주어야함!  public virtual void Die()//일반 메소드: 추상클래스는 일반 메소드 또한 가질 수 있다.  { isAlive = false; } } public abstract class Birds : Animal//동물이라는 카테고리 속 조류라는 카테고리 { protected Birds(Beak beak) { this.beak = beak; } public Beak beak { get; private set; } } public class Sparrow : Birds, IFly//조류에 속하는 참새 객체 { public Sparrow(Beak beak) : base(beak) { } public void Fly() { Console.WriteLine(\u0026#34;포로록~ 참새 난다~\u0026#34;); } public override void Eat() { Console.WriteLine(\u0026#34;참새 쌀알 먹는다. 콕콕!\u0026#34;); } } public class Parrot : Birds, IFly//조류에 속하는 앵무새 객체 { public Parrot(Beak beak) : base(beak) { } public void Fly() { Console.WriteLine(\u0026#34;푸드덕~ 앵무새 난다~\u0026#34;); } public override void Eat() { Console.WriteLine(\u0026#34;츄릅~ 앵무새 메뚜기 먹는다!\u0026#34;); } }   abstract class(추상클래스)의 특징은? 🧐  클래스 안에 추상메소드가 하나라도 존재한다면, 그 클래스는 반드시 추상클래스여야한다. 추상클래스: abstract class [\u0026quot;클래스 이름\u0026quot;], 추상메소드: abstract [\u0026quot;반환타입\u0026quot;] [\u0026quot;메소드 이름\u0026quot;]( [\u0026quot;파라미터\u0026quot;] )로 표현한다. 추상메소드는 내부가 구현되지않은 상태여야한다. (이전에 포스팅했던 인터페이스가 추상메소드만으로만 이루어진 것) 접근한정자를 정해주지않으면 private 디폴트 값이다. 필드와 일반메소드 모두 가지고 있을 수 있다.(인터페이스와 가장 큰 차이점 중 하나) 다른 일반 클래스와 마찮가지로 다중상속이 불가능하다. 인터페이스와 마찮가지로 인스턴스가 불가능하다.  ** 다음 포스팅은 일반 클래스와 상속에 대해서 다루겠다!\n","permalink":"https://ohhyemi.github.io/posts/studying10_abstract/","summary":"오늘은 추상 클래스에 대해 알아보쟈!\nabstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.\n💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, \u0026ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.\u0026rdquo; 라는 계약이 생긴다.","title":"abstract class: 추상클래스"},{"content":"interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.\nCan Do를 알려주는 역할을 한다.\ninterface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시 만약 조류라는 클래스가 있다고 하자. 이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다. 하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?\n이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).\n이런 경우에 사용해야 할 것이 interface이다. 즉, 인터페이스는 어떠한 기능을 수행할 수 있는지 알려주는 역할을 하는 것이다. Can Do!\n🍑 위의 설명을 코드로 만들어 보자!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public interface IFly { void Fly(); } public abstract class Birds : Animal { protected Birds(Beak beak) { this.beak = beak; } public Beak beak { get; private set; } } public class Sparrow : Birds, IFly { public void Fly() { Console.WriteLine(\u0026#34;포로록~ 참새 난다~\u0026#34;); } public Sparrow(Beak beak) : base(beak) { } } public class Parrot : Birds, IFly { public void Fly() { Console.WriteLine(\u0026#34;푸드덕~ 앵무새 난다~\u0026#34;); } public Parrot(Beak beak) : base(beak) { } } public class Penguin : Birds, ISwim { public void Swim() { Console.WriteLine(\u0026#34;슈슉~ 펭귄 수영한다~\u0026#34;); } public Penguin(Beak beak) : base(beak) { } } public class SugarGlider : Mammalia, IFly { public void Fly() { Console.WriteLine(\u0026#34;슝~ 슈가 글라이더 난다~\u0026#34;); } }   interface(인터페이스)의 특징은? 🧐  내부를 구체화 하지않은 메소드만으로 이루워져있다. 인스턴스가 불가능하다.: 다른 일반 클래스처럼 new로 인스턴스화 할 수 없다. 반드시 상속을 통해 사용해야한다. 다중 상속이 가능하다! 인터페이스를 상속한 클래스는 반드시 인터페이스 안의 모든 메소드를 구체화 해야한다. 접근 한정자가 항상 public이다. 내부 메소드 또한 public으로 구현이된다.  ** 다음 포스팅은 abstract class에 대해서 공부해보도록 하겠당~\n","permalink":"https://ohhyemi.github.io/posts/studying9_interface/","summary":"interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.\nCan Do를 알려주는 역할을 한다.\ninterface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시 만약 조류라는 클래스가 있다고 하자. 이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다. 하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?\n이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).","title":"interface: 인터페이스"},{"content":"음\u0026hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다. 나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실\u0026hellip;!😱 그래서 오늘 공부해보려고 한다.\nBFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.  단점   답이 아닌 경로가 깊다면 해를 구하는 데에 오래 걸린다. 왜?: 다시 돌아와서 탐색해야하기 때문에.  💚 딱히 장단점은 중요하지 않은 것 같다. 최단 경로 찾기에는 어쨋든 최적해를 보장해주는 BFS를 써야하지않을까? DFS는 SCC를 찾는 데 사용한다고 한다.\n","permalink":"https://ohhyemi.github.io/posts/studying8_bfs_dfs2/","summary":"음\u0026hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다. 나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실\u0026hellip;!😱 그래서 오늘 공부해보려고 한다.\nBFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.","title":"BFS: 너비우선탐색, DFS: 깊이우선탐색(2)"},{"content":"음\u0026hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다\u0026hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서.. 원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋\nGraph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.\n 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법\n 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i \u0026lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List\u0026lt;int\u0026gt;[] Graph = new List\u0026lt;int\u0026gt;[V + 1]; for (int i = 1; i \u0026lt; N + 1; i++) { Graph[i] = new List\u0026lt;int\u0026gt;(); foreach(v in AdjacencyVertices) { Graph[i].Add(v);//간선으로 연결된 정점들을 모두 추가  } }   BFS를 알아보자 🧐  BFS(Breadth First Search)는 너비우선탐색으로 어떠한 정점으로부터 인접한 정점을 먼저 방문하는 탐색 알고리즘이다.  🍑 코드 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  List\u0026lt;int\u0026gt;[] ve;//정점과 정점마다 연결된 다른 정점들의 리스트의 배열 List\u0026lt;int\u0026gt; visited;//방문한 정점  void BFS(int v)//시작 정점 { Queue\u0026lt;int\u0026gt; queue_bfs = new Queue\u0026lt;int\u0026gt;(); queue_bfs.Enqueue(v); visited.Add(v);//방문함!  while (queue_bfs.Count \u0026gt; 0)//큐의 갯수가 1개 이상일 때,  { var w = queue_bfs.Dequeue();//방문한 정점을 빼면서  for (int i = 0; i \u0026lt; ve[w].Count; i++)//인접한 정점들을 탐색  { if (!visited.Contains(ve[w][i]))//방문하지 않은 정점이 있다면  { queue_bfs.Enqueue(ve[w][i]); visited.Add(ve[w][i]);//방문!  } } } }   DFS를 알아보자 🧐  DFS(Depth First Search)는 깊이우선탐색으로   시작 정점으로 부터 인접한 정점 중 한 정점을 방문한다. 그 정점을 기준으로 1을 반복한다. 더 이상 인접한 정점이 없으면, 다시 이전 정점으로 돌아간다(백트래킹). 모든 정점을 방문할 때까지 1~3을 반복한다.  🍑 코드 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  List\u0026lt;int\u0026gt;[] ve;//정점과 정점마다 연결된 다른 정점들의 리스트의 배열 List\u0026lt;int\u0026gt; visited;//방문한 정점  void DFS(int v)//시작 정점  { if (visited.Contains(v)) //이미 방문한 곳이라면 return  { return; } visited.Add(v);//방문한 정점추가  for (int i = 0; i \u0026lt; ve[v].Count; i++) { if (!visited.Contains(ve[v][i]))//방문하지 않은 인접 정점을 방문하러가자!  { DFS(ve[v][i]); } } }```   ","permalink":"https://ohhyemi.github.io/posts/studying7_bfs_dfs/","summary":"음\u0026hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다\u0026hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서.. 원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋\nGraph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.\n 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법\n 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i \u0026lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List\u0026lt;int\u0026gt;[] Graph = new List\u0026lt;int\u0026gt;[V + 1]; for (int i = 1; i \u0026lt; N + 1; i++) { Graph[i] = new List\u0026lt;int\u0026gt;(); foreach(v in AdjacencyVertices) { Graph[i].","title":"BFS: 너비우선탐색, DFS: 깊이우선탐색(1)"},{"content":"알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)\n이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \u0026ldquo;0\u0026rdquo; 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.\n정수가 \u0026ldquo;0\u0026quot;일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.\n👉출력 재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  using System; using System.Collections.Generic; namespace Algorithm15 { class Beakjoon10773 { static void Main(string[] args) { var k = int.Parse(Console.ReadLine()!); var stack = new Stack\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; k; i++) { var input = int.Parse(Console.ReadLine()!); if (input == 0)//0이 들어오면 이전 것을 pop  { stack.Pop(); } else { stack.Push(input);//그렇지않다면 push  } } int sum = 0; foreach (var s in stack) { sum += s; } Console.WriteLine(sum); } } }   후입선출인 Stack의 개념을 이용한 문제였다. 너무 쉬운 문제를 선택해버렸을지도..?ㅎㅎ\n문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm15_10773/","summary":"알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)","title":"AlgorithmStudy_백준 10773"},{"content":"오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다. 하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다. 그리고 그건 불가능한 게 맞다. 하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.\nMaterialPropertyBlock의 활용 🧐  Create -\u0026gt; Shader -\u0026gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.   💚2 - 예시\n1 2 3 4 5 6 7 8 9 10  Shader \u0026#34;Custom/TestShader\u0026#34; { Properties { [PerRendererData]_Color (\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _MainTex (\u0026#34;Albedo (RGB)\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Glossiness (\u0026#34;Smoothness\u0026#34;, Range(0,1)) = 0.5 _Metallic (\u0026#34;Metallic\u0026#34;, Range(0,1)) = 0.0 } }   변경점 적용.  💚3 - 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  using UnityEngine; public class MaterialColorChanger : MonoBehaviour { public Color toColor; private Renderer _renderer; public Renderer Renderer { get { if (_renderer == null) { _renderer = GetComponent\u0026lt;Renderer\u0026gt;(); } return _renderer; } } public void ChangeColor() //material의 컬러를 직접적으로 바꾸는 방법: 새로운 material instance가 생성됨.  { Renderer.material.color = toColor; } public void ChangeColorWithPropertyBlock()//property의 값을 바꾸는 방법. 하나의 material을 사용하면서 서로 다른 값을 가질 수 있음.  { var propertyBlock = new MaterialPropertyBlock(); Renderer.GetPropertyBlock(propertyBlock); propertyBlock.SetColor(\u0026#34;_Color\u0026#34;, toColor); Renderer.SetPropertyBlock(propertyBlock); } }   차이점 확인 🧐 같은 머티리얼을 공유하는 4개의 오브젝트들을 미리 static batching이 되도록 설정을 해놓은 상태입니다.\n 렌더러에서 머티리얼의 값을 직접적으로 바꿨을 경우.   배칭이 불가능한 이유: 서로 다른 머티리얼을 사용하기 때문. 서로 다른 머티리얼을 사용한다는 것은 런타임 중에 새로운 머티리얼을 인스턴스했다는 것.  프로퍼티의 값을 통해 바꿨을 경우.   배칭이 불가능한 이유: 서로 다른 프로퍼티 값을 가지고 있기 때문.(즉 배칭을 유지하면서 컬러를 바꾸는 것은 불가능) 하나의 공유된 머티리얼을 사용하지만 각자 다른 프로퍼티 값을 가지고 있다는 것.   하지만 같은 프로퍼티 값을 가지고 있는 오브젝트들은 배칭이 유지된다.   ⚠️주의⚠️\n[PerRendererData]을 쓰지 않을 경우: 함수들은 사용이 가능하지만 내부적으로 새 머티리얼 인스턴스 하기 때문에 결국은 1번의 방법과 같은 결과를 낳는다.\n","permalink":"https://ohhyemi.github.io/posts/studying6_drawcall3/","summary":"오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다. 하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다. 그리고 그건 불가능한 게 맞다. 하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.\nMaterialPropertyBlock의 활용 🧐  Create -\u0026gt; Shader -\u0026gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.","title":"Draw Call: 드로우콜(3)"},{"content":"알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.\n👉입력 입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 테스트 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 64 이상 1,000,000 이하인 하나의 정수로 주어진다.\n👉출력 출력은 표준출력을 사용한다. 하나의 테스트 데이터에 대한 답을 하나의 줄에 출력한다. 각 테스트 데이터에 대해, 주어진 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하여 회문이 될 수 있다면 1을, 그렇지 않다면 0을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  using System; using System.Collections.Generic; namespace Algorithm14 { class Baekjoon11068 { static void Main(string[] args) { var t = int.Parse(Console.ReadLine()!); var arr = new int[t]; for (int i = 0; i \u0026lt; t; i++) { arr[i] = int.Parse(Console.ReadLine()!); } for (int i = 0; i \u0026lt; t; i++) { int result = 0; for (int j = 2; j \u0026lt;= 64; j++) { var convert = ConvertJ(arr[i], j); result = Check(convert); if (result == 1) { break; } } Console.WriteLine(result); } int Check(List\u0026lt;int\u0026gt; list)//회문인지 체크  { for (int i = 0; i \u0026lt; list.Count / 2; i++) { if (list[i] != list[list.Count - i - 1]) { return 0; } } return 1; } List\u0026lt;int\u0026gt; ConvertJ(int value, int j)//진법 변환(사실 여기서 뒤집어주어야 알맞은 값이 나오지만 사실 이 문제에서는 상관이없기때문에 뒤집지않았다.)  { List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); while (value / j \u0026gt; 0) { list.Add(value % j); value /= j; } list.Add(value); return list; } } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm14_11068/","summary":"알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.","title":"AlgorithmStudy_백준 11068"},{"content":"이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.\nBatch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명\nProject Setting \u0026gt; Player 에서 사용이 체크가 되어있는지 확인.  Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법  버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적. 같은 머티리얼을 사용하는 메쉬들을 렌더링할 때 드로우콜을 줄일 수 있다.(동일한 머티리얼 인스턴스여야 함) 배경 같은 요소(트랜스폼 등이 바뀌지 않는 오브젝트)에 적용해주기에 적합함.  ⚠️주의⚠️\n메모리가 추가로 필요함. 해당되는 오브젝트들은 처음부터 Scene에 존재해야 함. 동일한 머터리얼을 사용할 지라도 스크립트에서 Renderer.material.color = Color.red;처럼 머터리얼의 속성을 변경한다면 복사본이 생성되기 때문에 적용되지않는다(Renderer.sharedMaterial사용으로 해결가능).\nDynamic Batching: Static 플래그가 체크되어있지않은 모든 오브젝트에 적용 됨.   매 프레임, 오브젝트들의 버텍스 정보를 합쳐 버텍스 버퍼와 인덱스 버퍼에 담아 GPU가 렌더링 함. 따라서 매 프레임마다 오버헤드가 발생. 그러나 드로우콜을 줄임으로 전체적인 성능 향상.  ⚠️주의⚠️\nSkinned Mesh에는 적용이 되지않음.\n버텍스가 너무 많은 메쉬에는 적용이 되지않음.\n2D 환경에서는 드로우콜을 어떻게 줄이나요? 🧐  Sprite Mode: Multiple 사용. Sprite Atlas 이용.  참고자료: 유니티 그래픽스 최적화 스타트업\n","permalink":"https://ohhyemi.github.io/posts/studying5_drawcall2/","summary":"이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.\nBatch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명\nProject Setting \u0026gt; Player 에서 사용이 체크가 되어있는지 확인.  Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법  버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적.","title":"Draw Call: 드로우콜(2)"},{"content":"오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!\nDraw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명\n 오브젝트가 실제 화면에 렌더링 되려면 CPU -\u0026gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재. CPU 메모리에서 GPU 메모리로 위의 정보 데이터들의 복사가 이루워짐.(게임 수행 내내 데이터는 메모리에 상주) GPU에는 렌더링 할 것의 상태 정보를 담는 테이블이 존재.(Render States: GPU 메모리의 데이터 위치 정보 보유) 새로운 오브젝트를 그릴 때 마다 상태 변경 CPU -\u0026gt; GPU로 상태 변경 명령을 내림.(변경이 필요한 부분만) CPU -\u0026gt; GPU로 상태 변경 명령(render state change) + 렌더 명령(Draw Primitive Call(DP Call)) = 드로우콜 CPU -\u0026gt; 커맨드 버퍼(Command Buffer) -\u0026gt; GPU 순으로 명령이 이루워짐.  Draw Call이 많으면 무엇이 문제일까? 🧐  명령을 GPU에서 사용하는 신호로 변환해야하기 때문에 CPU에 부담이 된다.(CPU 오버헤드)  어떻게 해야할까? 🧐  렌더링에 관련된 작업들을 별도의 쓰레드에서 수행하게한다.(Multithreaded Rendering)  드로우콜을 줄인다.  ⚠️주의⚠️\n드로우콜을 줄이는 데에는 텍스쳐의 크기 또는 폴리곤의 수를 줄이는 것과 관련이 없다!\nDraw Call은 어떻게 발생되는 걸까? 🧐 보통 오브젝트를 그릴 때 Mesh가 1개, Material이 1개일 경우 드로우콜이 한 번 일어난다.\n Mesh가 여러 개인 경우 Material이 여러 개인 경우 Shader에 따라서\u0026hellip;   ⚠️주의⚠️\n수많은 상태 변경들을 포함하기 때문에 드로우콜의 비용은 개당으로 계산하기 어렵다.\n참고자료: 유니티 그래픽스 최적화 스타트업\n","permalink":"https://ohhyemi.github.io/posts/studying4_drawcall1/","summary":"오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!\nDraw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명\n 오브젝트가 실제 화면에 렌더링 되려면 CPU -\u0026gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재.","title":"Draw Call: 드로우콜(1)"},{"content":"유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.\nGeneric class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.\n (c++ 의 템플릿과 비슷!)\n왜 사용하는거야? 🧐  기능이 같은 클래스를 타입만 바꾸어 새롭게 구현할 필요없이 Generic class로 구현하면 여러 타입으로 하나의 클래스를 활용할 수 있다. 대표적 예시로 List\u0026lt;T\u0026gt;가 있다.  어떻게 사용해야해? 🧐  public class [ClassName]\u0026lt;T\u0026gt; 로 선언. 여러개의 타입을 사용하고 싶을 때는 \u0026lt;T1, T2 ...\u0026gt; 이런 식으로 나열하면 된다. 제네릭 타입에 제약을 두고 싶을 경우 where T : [제약조건]과 같이 마지막에 조건을 붙인다.  ⚠️주의⚠️ 만약 제네릭 클래스가 MonoBehaviour를 상속하고 있을 때, GameObject에 AddComponent를 바로 할 경우 null이 된다. 각 제네릭 타입마다 class를 새로 생성 후 가능하다.\n⛔ 옳지않은 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  using System; using UnityEngine; namespace MyTween { public class Tween\u0026lt;T1, T2\u0026gt;: MonoBehaviour { private T1 target; private T2 v_end; } public static class TweenManager { public static Tween\u0026lt;Transform, Vector3\u0026gt; Move(this Transform tr, Vector3 to, float duration) { Tween\u0026lt;Transform, Vector3\u0026gt; tween = tr.gameObject.AddComponent\u0026lt;Tween\u0026lt;Transform, Vector3\u0026gt;\u0026gt;();//null 반환!!  return tween; } } }   💚 옳은 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System; using UnityEngine; namespace MyTween { public class TweenVector3 : Tween\u0026lt;Transform, Vector3\u0026gt; { } public static class TweenManager { public static Tween\u0026lt;Transform, Vector3\u0026gt; Move(this Transform tr, Vector3 to, float duration) { TweenVector3 tween = tr.gameObject.AddComponent\u0026lt;TweenVector3\u0026gt;();//성공적인 반환!!  return tween; } } }   ","permalink":"https://ohhyemi.github.io/posts/studying3_generic/","summary":"유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.\nGeneric class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.","title":"Generic: 제너릭 클래스"},{"content":"알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\ndž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.\n👉입력 첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 \u0026lsquo;-\u0026rsquo;, \u0026lsquo;=\u0026lsquo;로만 이루어져 있다.\n단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.\n👉출력 입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  using System; using System.Collections.Generic; using System.Text; namespace Algorithm13 { class Baekjoon2941 { static void Main(string[] args) { List\u0026lt;string\u0026gt; list = new List\u0026lt;string\u0026gt; {\u0026#34;c=\u0026#34;, \u0026#34;c-\u0026#34;, \u0026#34;dz=\u0026#34;, \u0026#34;d-\u0026#34;, \u0026#34;lj\u0026#34;, \u0026#34;nj\u0026#34;, \u0026#34;s=\u0026#34;, \u0026#34;z=\u0026#34;}; var input = new StringBuilder(Console.ReadLine()); foreach (var s in list) { input.Replace(s, \u0026#34;*\u0026#34;);//해당되는 문자열을 다른 문자로 변경  } Console.WriteLine(input.Length);//문자열의 길이 출력  } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm13/","summary":"알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\ndž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.\n👉입력 첫째 줄에 최대 100글자의 단어가 주어진다.","title":"AlgorithmStudy_백준 2941"},{"content":"알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.\n33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, \u0026hellip;\nn을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.\n생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97\n10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.\n👉입력 입력은 없다.\n👉출력 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  using System; using System.Linq; namespace Algorithm12 { class Baekjoon4673 { static void Main(string[] args) { var arr = new bool[10000]; //생성자가 있는 지 없는 지 체크해주는 배열!  for (int i = 0; i \u0026lt; arr.Length; i++) { var n = i + 1; //실제 체크해야 하는 수는 인덱스 보다 1 더 큼.  if (arr[i] == false) //만약 생성자가 없다면  { Console.WriteLine(n);//출력  } var list = n.ToString().ToArray();//수를 array 로 변환  foreach (var num in list) { n += num - \u0026#39;0\u0026#39;;//수에 각 자리 수를 더함  } if (n - 1 \u0026lt; arr.Length)//만약 인덱스가 arr의 길이보다 작을 경우에는  { arr[n - 1] = true;//생성자가 있다고 true 로 변경하기  } } } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm12/","summary":"알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다.","title":"AlgorithmStudy_백준 4673"},{"content":"유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다. DoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.\n나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!\nExtenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야? 🧐  인스턴스 메서드를 추가하려면 해당 클래스 안에 메서드를 추가해야한다. 하지만 접근이 불가한 클래스라면 ??? Extenstion Method를 사용하자!  어떻게 사용해야해? 🧐  static class static method public Extenstion Method는 첫번째 파라미터로 반드시 클래스명을 지정해야 함.public static void Function(this T parm) 이 파라미터 앞에 반드시 this 키워드를 추가할 것! 만약 Extenstion Method 사용 후 또 다른 확장 메소드를 쓰고 싶을 시 this로 들어왔던 첫 파라미터를 반환 해주면 된다.  🍑 예시: tween 만들기 프로젝트에 일부를 이용했다..ㅎㅎ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  using System.Collections; using UnityEngine; namespace MyTween { public static class Tween { public static Transform Move(this Transform tr, Vector3 to, float duration, AnimationCurve ease) { return tr; } public static Transform Scale(this Transform tr, Vector3 to, float duration, AnimationCurve ease) { return tr; } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using MyTween; public class ButtonDirecting : MonoBehaviour, IPointerDownHandler, IPointerUpHandler { public AnimationCurve ease; public Vector2 toSize = Vector2.one; public float duration; private bool isTweening = false; private event Action onClick; private Vector2 fromSize; public void OnClick() { transform.Move(Vector3.one, 1f, ease).Scale(Vector3.one, 1f); } }   ","permalink":"https://ohhyemi.github.io/posts/studying2/","summary":"유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다. DoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.\n나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!\nExtenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야?","title":"Extenstion Method: 확장 메서드"},{"content":"알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n이미지 보러가기\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다. 그림에서 흐릿하게 보이는 모든 부분은 원래 문제와 다르지 않다.\n빈 칸에 들어갈 두 자연수가 주어졌을 때 문제를 해결하는 프로그램을 작성하자.\n👉입력 첫 번째 줄에 테스트 케이스의 수 T (1 ≤ T ≤ 50 000)가 주어진다. 이후 T개의 테스트 케이스가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있으며, 각 줄에는 두 개의 정수 A와 B (1 ≤ A, B ≤ 1 023, A ≠ B)가 공백을 사이로 두고 주어진다. 이는 첫 번째 빈 칸에는 A를, 두 번째 빈 칸에는 B를 넣었을 때 답을 구하라는 의미이다\n👉출력 각 테스트 케이스에 대해 답을 한 줄에 하나씩 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm11 { class Baekjoon13116 { static void Main(string[] args) { int tCount = int.Parse(Console.ReadLine()!); var tlist = new List\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; tCount; i++) { var input = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); tlist.AddRange(input); } for (int i = 0; i \u0026lt; tCount; i++) { int n1 = tlist[2 * i]; int n2 = tlist[2 * i + 1]; while (n1 != n2) { while (n1 \u0026lt; n2) //n2가 n1보다 크지 않을 때까지  { n2 /= 2; } if (n1 == n2) //같다면 break;  { break; } n1 /= 2; //n1이 n2보다 크지 않을 때까지  } Console.WriteLine(n1 * 10); } } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm11/","summary":"알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n이미지 보러가기\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다.","title":"AlgorithmStudy_백준 13116"},{"content":"알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.\n👉출력 첫째 줄에 정답을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm10 { class Baekjon1541 { static void Main(string[] args) { var op = new char[] {\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;}; var input = Console.ReadLine(); var opList = input!.ToCharArray().Where(a =\u0026gt; a is \u0026#39;+\u0026#39; or \u0026#39;-\u0026#39;).ToArray(); var nList = input!.Split(op).Select(int.Parse).ToArray();//연산자를 기준으로 SPLIT  if (nList.Length == 1) //수 하나만 들어왔을 경우(연산자가 없는 경우)  { Console.WriteLine(nList[0]); return; } int re = nList[0]; List\u0026lt;int\u0026gt; results = new List\u0026lt;int\u0026gt;();//결과값들을 저장해 놓을 공간(-기준으로 끊어 +연산한 값들)  for (int i = 0; i \u0026lt; opList.Length; i++) { if (opList[i] == \u0026#39;+\u0026#39;) { re += nList[i + 1]; } else { results.Add(re);//-를 만나기 전까지 더한 수의 합을 ADD  re = nList[i + 1];// -를 만난 후 다음 수  } if (i == opList.Length - 1)//다음 연산자가 없을 경우  { results.Add(re); } } var result = results[0]; for (int i = 1; i \u0026lt; results.Count; i++) { result -= results[i];//처음 값에서 나머지 값을 모두 빼줌  } Console.WriteLine(result); } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm10/","summary":"알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다.","title":"AlgorithmStudy_백준 1541"},{"content":"시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =\u0026gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  ","permalink":"https://ohhyemi.github.io/posts/studying1/","summary":"시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =\u0026gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  ","title":"Studying_복잡도"},{"content":"알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. (1 ≤ N ≤ 100)\n👉출력 각 테스트 케이스마다 P(N)을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  using System; using System.Linq; namespace Algorithm9 { class Baekjoon9461 { static void Main(string[] args) { var t = int.Parse(Console.ReadLine()!); var n = new int[t];//n 수열에서 뽑아 출력해야하는 n번째 수들의 배열  for (int i = 0; i \u0026lt; t; i++) { n[i] = int.Parse(Console.ReadLine()!); } var list = n.ToList(); list.Sort(); var max = list[t - 1];//입력 중 가장 큰 숫자  var padovan = new long[max]; padovan[0] = 1; padovan[1] = 1; padovan[2] = 1; while (padovan[^1] == 0) { for (int i = 3; i \u0026lt; max; i++)//입력된 가장 큰 수 번째까지 수열을 구한다.  { if (padovan[i] != 0) { continue; } padovan[i] = padovan[i - 3] + padovan[i - 2]; //(규칙) =\u0026gt; i번째는 i-3번째 + i-2번째  } } var result = new long[t];//결과값을 담을 배열  for (int i = 0; i \u0026lt; t; i++) { result[i] = padovan[n[i] - 1];//결과값의 배열에 n값의 순서대로 수열의 값을 대입  } Console.WriteLine(String.Join(\u0026#34;\\n\u0026#34;, result)); } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm9/","summary":"알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.","title":"AlgorithmStudy_백준 9461"},{"content":"블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!\r알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.\r그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑\r그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만... (막은데에는 이유가 있을거라고 생각하고...다른 방법을 선택!)\r그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode!\r 참조\nShortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.\n 여기서 snippet이란 재사용이 가능한 소스코드이다. 우리가 작성하는 content안에서 이 Shortcode를 불러옴으로서 원하는 기능을 수행할 수 있게 해준다.\n {{\u0026lt; Shortcode Parmeters \u0026gt;}} 형식을 따라 MarkDown에서 사용이 가능하다! html 코드들을 적용 시킬 수 있다!  자세한 설명\nShortcode를 이용해 Text에 Color 입히기 🎨   layout 폴더 아래 shortcodes라는 이름으로 폴더 생성!\n  자신이 이 Shortcode를 부를 때 사용할 이름으로 [Name].html 파일 생성! (내 경우 이름을 color라고 지정)\n  \u0026lt;span style=color:{{ .Get \u0026quot;color\u0026quot; }}\u0026gt;{{ .Get \u0026quot;text\u0026quot; }}\u0026lt;/span\u0026gt;  작성!\n  content를 만들 때 색깔을 입히고 싶은 곳에 {{\u0026lt; [Name] color=\u0026#34;[Color]\u0026#34; text=\u0026#34;[Text]\u0026#34; \u0026gt;}} 요로코롬 Shortcode를 호출하고 적용!\n  처음에는 이해하기 어려웠는데 Unity에서 쓰는 Component랑 비슷하다고 생각하니 개념에 좀 더 쉽게 다가갈 수 있었다.(어떤 오브젝트에게 어떠한 일을 시키고 싶을 때 Component를 추가하는 것 처럼?)\n","permalink":"https://ohhyemi.github.io/posts/markdown1/","summary":"블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!\r알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.\r그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑\r그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만... (막은데에는 이유가 있을거라고 생각하고...다른 방법을 선택!)\r그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode!\r 참조\nShortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.","title":"Hugo와 MarkDown: Text Color"},{"content":"알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.\n👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm8 { class Beakjun1181 { static void Main(string[] args) { List\u0026lt;string\u0026gt; words = new List\u0026lt;string\u0026gt;(); var count = int.Parse(Console.ReadLine()!); for (int i = 0; i \u0026lt; count; i++) { string word = Console.ReadLine(); if (words.Exists(x=\u0026gt; x== word) == false) { words.Add(word); } } //알파벳 순으로 정렬  var list = words.OrderBy(x =\u0026gt; x); //길이 순으로 정렬  var result = list.OrderBy(x =\u0026gt; x.Length); Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, result)); } } }   😿 풀이 2 시간초과로 맞히지 못한 Quick Sort를 이용한 풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  using System; using System.Collections.Generic; namespace Algorithm8 { class Beakjun1181 { static void Main(string[] args) { List\u0026lt;string\u0026gt; words = new List\u0026lt;string\u0026gt;(); var count = int.Parse(Console.ReadLine()!); for (int i = 0; i \u0026lt; count; i++) { string word = Console.ReadLine(); if (words.Exists(x=\u0026gt; x== word) == false) { words.Add(word); } } int left = 0; int right = words.Count - 1; Sort(left, right); void Sort(int _left, int _right) { if (_left \u0026gt;= _right) { return; } var pivot = Divide(_left, _right); Sort(_left, pivot - 1); Sort(pivot + 1, _right); } int Divide(int _left, int _right) { int _pivot = _left; _left++; while (true) { if (words[_pivot].Length \u0026gt;= words[_left].Length) { if (words[_pivot].Length == words[_left].Length)//길이가 같을 경우  { for (int i = 0; i \u0026lt; words[_pivot].Length; i++)//각 자리를 비교하기  { if (words[_pivot][i] \u0026lt; words[_left][i])//피봇의 알파벳이 우선일 경우  { break; } else if(words[_pivot][i] \u0026gt; words[_left][i])//피봇의 알파벳이 후순위일 경우  { _left++;//left를 한 칸 뒤로 옮기기  break; } } } else//피봇의 값이 왼쪽의 값보다 길 경우  { _left++;//left를 한 칸 옮기기  } } if (words[_pivot].Length \u0026lt;= words[_right].Length) { if (words[_pivot].Length == words[_right].Length)//길이가 같을 경우  { for (int i = 0; i \u0026lt; words[_pivot].Length; i++)//각 자리를 비교하기  { if (words[_pivot][i] \u0026gt; words[_left][i])//피봇의 알파벳이 후순위일 경우  { break; } else if (words[_pivot][i] \u0026lt; words[_right][i])//피봇의 알파벳이 우선일 경우  { _right--;//right를 한 칸 앞으로 옮기기  break; } } } else { _right--;//right를 한 칸 앞으로 옮기기  } } if (_left \u0026gt; _right)//left와 right가 역전되었을 경우  { break; } if (words[_left].Length \u0026gt; words[_right].Length)// left의 값이 right의 값보다 클 경우 서로 swap  { (words[_left], words[_right]) = (words[_right], words[_left]); } } (words[_pivot], words[_right]) = (words[_right], words[_pivot]);//역전된 right값과 pivot값을 swap  return _right;//right반환 =\u0026gt; 다음 pivot  } Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, words)); }   최악의 경우 시간복잡도가 O(n^2)로 매우 성능이 떨어지게 된다. 아마 이걸 잡나보다\u0026hellip;. Quick Sort 말고 Merge Sort를 사용해 볼 걸 그랬다\u0026hellip;\n[문제풀러가기] (https://www.acmicpc.net/problem/1181)\n","permalink":"https://ohhyemi.github.io/posts/algorithm8/","summary":"알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.\n👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.","title":"AlgorithmStudy_백준 1181"},{"content":"알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace Algorithm7 { class Beakjun1929 { static void Main(string[] args) { var list = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int m = list[0]; int n = list[1]; List\u0026lt;int\u0026gt; result = new List\u0026lt;int\u0026gt;(); //소수의 정의 : 1과 자기자신으로 밖에 나눌 없는 것..  for (int i = m; i \u0026lt;= n; i++) { if (i == 1) { continue; } if (i is \u0026gt; 1 and \u0026lt; 4)//2, 3은 소수  { result.Add(i); continue; } if (i % 2 == 0)//2의 배수는 모두 합성수  { continue; } bool primeNum = true; for (int k = 1; (k * 2 + 1) \u0026lt;= Math.Sqrt(i); k++)//소수는 다 홀수이다. =\u0026gt; 2k + 1  { //합성수라면 수의 제곱근보다 작거나 같은 수가 존재한다.  if (i % (k * 2 + 1) == 0) { primeNum = false;//소수가 아니다!  break; } } if (primeNum == true) { result.Add(i); } } StringBuilder sb = new StringBuilder(String.Join(\u0026#34;\\n\u0026#34;, result.ToArray())); Console.WriteLine(sb); } } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm7/","summary":"알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.","title":"AlgorithmStudy_백준 1929"},{"content":"알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 \u0026lt;3, 6, 2, 7, 5, 1, 4\u0026gt;이다.\nN과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)\n👉출력 예제와 같이 요세푸스 순열을 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; namespace Algorithm1 { public static class Program { public static void Main() { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int n = input[0]; int k = input[1]; var index = k - 1; Queue result = new Queue(); int[] people = new int[n]; for (int i = 0; i \u0026lt; n; i++) { people[i] = i + 1; } //배열로 하는 풀이  while (result.Count != n)//결과의 갯수가 n 값이 아닌동안  { if (people[index] \u0026gt; 0)//값이 0보다 크면  { result.Enqueue(people[index]);//결과에 enqeue  people[index] = 0;//결과에 넣은 값은 0으로  } if (result.Count == n) { break; } for (int i = 0; i \u0026lt; k; i++)//k번동안 인덱스 변경  { index = (index + 1) % n;//n의 크기를 넘지 않도록 설계  while(people[index] == 0)//값이 0인 경우 횟수로 치지 않음  { index = (index + 1) % n; } } } StringBuilder st = new StringBuilder(); st.Append(\u0026#34;\u0026lt;\u0026#34;); st.Append(string.Join(\u0026#34;, \u0026#34;, result.ToArray())); st.Append(\u0026#34;\u0026gt;\u0026#34;); Console.WriteLine(st); } } }   🍑풀이 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  using System; using System.Collections; using System.Linq; namespace Algorithm1 { public static class Program { public static void Main() { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int n = input[0]; int k = input[1]; Queue result = new Queue(); Queue que = new Queue(); for (int i = 1; i \u0026lt;= n; i++) { que.Enqueue(i); } //queue를 이용한 풀이  while (result.Count != n) { for (int i = 0; i \u0026lt; k - 1; i++)//k-1번째까지는 dequeue 후 다시 enqueue  { var pop =que.Dequeue(); que.Enqueue(pop); } result.Enqueue(que.Dequeue());//k번째에 결과값에 추가  } var r = string.Join(\u0026#34;, \u0026#34;, result.ToArray()); Console.WriteLine($\u0026#34;\u0026lt;{r}\u0026gt;\u0026#34;); } } }   🤣🤣 배열로 푼다고 고집부렸다가 애먹음..\n큐로 푸는 것이 정신건강에 좋은 것 같다.\n문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm6/","summary":"알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 \u0026lt;3, 6, 2, 7, 5, 1, 4\u0026gt;이다.\nN과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.","title":"AlgorithmStudy_백준 11866"},{"content":"알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.\n👉출력 M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  using System; using System.Linq; using System.Text; namespace Algorithm1 { public static class Program { public static void Main() { var count_n = int.Parse(Console.ReadLine()!); var n = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); var count_m = int.Parse(Console.ReadLine()!); var m = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); var result = new int[m.Length]; Array.Sort(n); for (int i = 0; i \u0026lt; count_m; i++) { if (m[i] \u0026lt; n[0] || m[i] \u0026gt; n[^1]) //값이 범위에서 벗어나면 0  { result[i] = 0; continue; } int pivot = count_n / 2; //이진탐색을 활용!  int left = 0; int right = count_n - 1; while (true) { if (left \u0026gt; right) { result[i] = 0; break; } else { if (m[i] == n[pivot]) // 피봇과 값이 같은 경우  { result[i] = 1; break; } else if (m[i] \u0026gt; n[pivot]) // 피봇의 값보다 큰 경우  { left = pivot + 1; } else // 피봇의 값보다 작은 경우  { right = pivot - 1; } pivot = (left + right) / 2; } } } Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, result)); } } }   시간초과로 애먹었음\u0026hellip;\n출력 방식을 바꾸었더니 해결이 되었다..! (원래는 result를 돌면서 하나씩 출력했었다)\n문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm5/","summary":"알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.","title":"AlgorithmStudy_백준 1920"},{"content":"C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = \u0026#34;안녕\u0026#34; + \u0026#34;하세요\u0026#34;; //\u0026#34;안녕\u0026#34; \u0026#34;하세요\u0026#34; -\u0026gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -\u0026gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다. 조합한 것을 string으로 반환이 가능하다. 길이가 충분히 길고 길이를 모를 때 사용하는 것이 바람직하다.  1 2 3 4 5 6  StringBuilder sb1 = new StringBuilder(\u0026#34;Hello\u0026#34;); //생성할 당시에 바로 넣기가 가능하다. StringBuilder sb2 = new StringBuilder(100); //버퍼공간을 미리 할당하는 것이 가능하다. //미리 할당을 해놓으면 크기가 넘어가는 데이터가 들어오기 전까지는 Append를 사용할 시 추가 공간을 마련하지않아도 되어 조금 더 빠르다.    🌟🌟 StringBuilder가 편리함에도 string이 필요한 이유  값의 변형없이 사용되는 string 에 대한 참조만이 필요할 경우.  1 2 3 4 5 6 7 8  string a = \u0026#34;immutable\u0026#34;; //s1, s2, s3는 내부적으로 버퍼를 가지고 있지않기 때문에 a와 같은 버퍼를 참조한다. //만약, string이 StringBuilder처럼 작동을 한다면... //s1, s2, s3는 내부적으로 버퍼를 가지고 있어야하고 이는 a의 내부 버퍼를 복사한 값을 가지고 있을 것이다. =\u0026gt; 메모리 낭비! string s1 = a; string s2 = b; string s3 = c;    멀티스레드 환경에서 string이 StringBuilder보다 안전하다.  1 2 3 4 5 6 7 8  string s = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34; + \u0026#34;c\u0026#34;; //string을 조합할 때는 연산의 최소 단위인 원자적 연산을 하기 때문에 스레드가 연산 중간에 간섭할 수 없어 값이 변할 위험이 없다.  StringBuilder sb = new StringBuilder(); sb.Append(\u0026#34;a\u0026#34;); sb.Append(\u0026#34;b\u0026#34;); sb.Append(\u0026#34;c\u0026#34;); //StringBuilder로 조합할 경우에는 원자적 연산이 아니기 때문에 멀티스레드 환경에서 값이 변형될 위험이 있다.   ","permalink":"https://ohhyemi.github.io/posts/csharp1/","summary":"C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = \u0026#34;안녕\u0026#34; + \u0026#34;하세요\u0026#34;; //\u0026#34;안녕\u0026#34; \u0026#34;하세요\u0026#34; -\u0026gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -\u0026gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다.","title":"c#_string_StringBuilder"},{"content":"알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.\n예를 들어 S=0001100 일 때,\n 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.  문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.\n👉입력 첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.\n👉출력 첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System; public class Program { public static void Main() {\tvar list = Console.ReadLine(); int count_zero = 0;//0이 쓰여진 카드 그룹의 갯수 (1 이 나오기 전까지의 카드 그룹) \tint count_one = 0;//1 이 쓰여진 카드 그룹의 갯수 (0 이 나오기 전까지의 카드 그룹) \tfor(int i = 0; i \u0026lt; list.Length - 1; ++i) { if(list[i] != list[i + 1]) //다음 카드와 비교했을 때 서로 다른 카드일 경우 \t{\tif(list[i] == \u0026#39;0\u0026#39;) { if(count_zero == 0 \u0026amp;\u0026amp; count_one == 0)//맨 처음 분기점 일 경우 \t{ count_one++;//그룹이 하나 생성 \t} count_zero++;//그룹 생성 \t} else if(list[i] == \u0026#39;1\u0026#39;) { if(count_zero == 0 \u0026amp;\u0026amp; count_one == 0) { count_zero++; } count_one++; } } } var result = Math.Min(count_zero, count_one); //더 작은 값을 출력 \tConsole.WriteLine(result);\t}\t}   문제풀러가기\n이..친구는.. 네번이나 틀렸다눈\u0026hellip; ㅠㅠ\n","permalink":"https://ohhyemi.github.io/posts/algorithm4/","summary":"알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.\n예를 들어 S=0001100 일 때,\n 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.","title":"AlgorithmStudy_백준 1439"},{"content":"알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.\n👉출력 첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System; public class Program { public static void Main() {\tstring input = Console.ReadLine(); var list = input.Split(\u0026#39; \u0026#39;); int fix = int.Parse(list[0]); int variable = int.Parse(list[1]); int price = int.Parse(list[2]); if(variable \u0026gt;= price)//가변지출이 제품 가격과 같거나 크면 손익이 날 수 없다. \t{ Console.WriteLine(-1);//-1 출력 \treturn; } int count = 1; int cost = 0; while(true) //카운트를 1씩 올리면서 손익분기점을 찾는다 \t{ cost = fix + variable * count; //총 비용 = 고정지출 + 가변지출 * 제품 갯수 \tif(price * count - cost \u0026gt; 0 )//순 이익 = 제품 가격 * 제품 갯수 - 총 비용 \t{ break; } count++; } Console.WriteLine(count); } }   🍑풀이 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using System; public class Program { public static void Main() {\tstring input = Console.ReadLine(); var list = input.Split(\u0026#39; \u0026#39;); int fix = int.Parse(list[0]); int variable = int.Parse(list[1]); int price = int.Parse(list[2]); if(variable \u0026gt;= price) { Console.WriteLine(-1); return; } int count = 1; // 0이 되는 지점 =\u0026gt; fix + variable * count = price * count  // fix = (price - variable) * count \tcount = fix/(price - variable) + 1; Console.WriteLine(count); } }   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm3/","summary":"알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.","title":"AlgorithmStudy_백준 1712"},{"content":"블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   ","permalink":"https://ohhyemi.github.io/posts/my-first-post/","summary":"블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   ","title":"My First Post"},{"content":"알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.\n줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.\n줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 👉입력 첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)\n👉출력 첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  using System; using System.Linq; public class Program { public static void Main() {\tint people; people = int.Parse(Console.ReadLine()); //시간이 가장 적은 사람이 순으로 줄을 서면 전체가 돈을 인출하는 시간의 총합이 줄어들음 \tvar list = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select((int.Parse)).ToArray();\tArray.Sort(list);//정렬 \tvar result = list[0]; for(int i = 1; i \u0026lt; list.Length; ++i) { list[i] = list[i-1] + list[i]; result += list[i];//걸리는 시간 더하기 \t} Console.WriteLine(result); }\t}   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm2/","summary":"알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다.","title":"AlgorithmStudy_백준 11399"},{"content":"알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;\tpublic class Program { public static void Main() {\tint count = int.Parse(Console.ReadLine()); //입력받아 int로 전환 \tstring nums = Console.ReadLine(); //공백없이 숫자 입력 \tint result = 0; foreach(var item in nums)//item : char \t{ //변환된 값을 더하기. \tresult += int.Parse(item.ToString());//char-\u0026gt;string-\u0026gt;int \t} Console.WriteLine(result);\t}\t}   문제풀러가기\n","permalink":"https://ohhyemi.github.io/posts/algorithm1/","summary":"알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;\tpublic class Program { public static void Main() {\tint count = int.","title":"AlgorithmStudy_백준 11720"}]